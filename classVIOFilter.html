<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eqvio: VIOFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eqvio
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classVIOFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VIOFilter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The implementation of the EqF for VIO.  
 <a href="classVIOFilter.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VIOFilter_8h_source.html">VIOFilter.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for VIOFilter:</div>
<div class="dyncontent">
<div class="center"><img src="classVIOFilter__coll__graph.png" border="0" usemap="#VIOFilter_coll__map" alt="Collaboration graph"/></div>
<map name="VIOFilter_coll__map" id="VIOFilter_coll__map">
<area shape="rect" title="The implementation of the EqF for VIO." alt="" coords="330,199,407,225"/>
<area shape="rect" href="structEqFCoordinateSuite.html" title="The suite of functions associated with a choice of coordinates for the EqF." alt="" coords="52,95,203,121"/>
<area shape="rect" href="structCoordinateChart.html" title=" " alt="" coords="5,5,220,32"/>
<area shape="rect" href="structVIOState.html" title="The states of the VIO system." alt="" coords="253,95,332,121"/>
<area shape="rect" href="structVIOSensorState.html" title="The states of the sensors of the VIO system." alt="" coords="245,5,367,32"/>
<area shape="rect" href="structVIOGroup.html" title="The Lie group used for VIO." alt="" coords="356,95,440,121"/>
<area shape="rect" href="structIMUVelocity.html" title="An Inertial Measurement Unit (IMU) reading." alt="" coords="465,95,566,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structVIOFilter_1_1Settings.html">Settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The settings of the EqF for VIO.  <a href="structVIOFilter_1_1Settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a666a3413e027f049fe82065a0a4cd0b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a666a3413e027f049fe82065a0a4cd0b3">VIOFilter</a> (const <a class="el" href="structVIOFilter_1_1Settings.html">VIOFilter::Settings</a> &amp;<a class="el" href="classVIOFilter.html#aad5e643d245dee8489cbae3dd5f7a2fa">settings</a>)</td></tr>
<tr class="memdesc:a666a3413e027f049fe82065a0a4cd0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the EqF using the given settings.  <a href="classVIOFilter.html#a666a3413e027f049fe82065a0a4cd0b3">More...</a><br /></td></tr>
<tr class="separator:a666a3413e027f049fe82065a0a4cd0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fd317292c498fbf744556e479d9820"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a26fd317292c498fbf744556e479d9820">initialiseFromIMUData</a> (const <a class="el" href="structIMUVelocity.html">IMUVelocity</a> &amp;imuVelocity)</td></tr>
<tr class="memdesc:a26fd317292c498fbf744556e479d9820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the EqF states using an IMU velocity measurement.  <a href="classVIOFilter.html#a26fd317292c498fbf744556e479d9820">More...</a><br /></td></tr>
<tr class="separator:a26fd317292c498fbf744556e479d9820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05118d5a1b771aed7b384e84bb341108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a05118d5a1b771aed7b384e84bb341108">setState</a> (const <a class="el" href="structVIOState.html">VIOState</a> &amp;xi)</td></tr>
<tr class="memdesc:a05118d5a1b771aed7b384e84bb341108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the EqF using the given state xi.  <a href="classVIOFilter.html#a05118d5a1b771aed7b384e84bb341108">More...</a><br /></td></tr>
<tr class="separator:a05118d5a1b771aed7b384e84bb341108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787faa9c8ad05a0eeeaa88076ac381bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a787faa9c8ad05a0eeeaa88076ac381bd">processIMUData</a> (const <a class="el" href="structIMUVelocity.html">IMUVelocity</a> &amp;imuVelocity)</td></tr>
<tr class="memdesc:a787faa9c8ad05a0eeeaa88076ac381bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an IMU velocity measurement.  <a href="classVIOFilter.html#a787faa9c8ad05a0eeeaa88076ac381bd">More...</a><br /></td></tr>
<tr class="separator:a787faa9c8ad05a0eeeaa88076ac381bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c10aed6c58f2b292be63523a57b8b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a2c10aed6c58f2b292be63523a57b8b2e">processVisionData</a> (const <a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> &amp;measurement)</td></tr>
<tr class="memdesc:a2c10aed6c58f2b292be63523a57b8b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a vision measurement.  <a href="classVIOFilter.html#a2c10aed6c58f2b292be63523a57b8b2e">More...</a><br /></td></tr>
<tr class="separator:a2c10aed6c58f2b292be63523a57b8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8706a7ab61bfde3e717253f455aa591d"><td class="memItemLeft" align="right" valign="top"><a id="a8706a7ab61bfde3e717253f455aa591d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a8706a7ab61bfde3e717253f455aa591d">getTime</a> () const</td></tr>
<tr class="memdesc:a8706a7ab61bfde3e717253f455aa591d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current filter time. <br /></td></tr>
<tr class="separator:a8706a7ab61bfde3e717253f455aa591d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058d8c5c5b709e7c1ab87818dc4d036e"><td class="memItemLeft" align="right" valign="top"><a id="a058d8c5c5b709e7c1ab87818dc4d036e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a058d8c5c5b709e7c1ab87818dc4d036e">isInitialised</a> () const</td></tr>
<tr class="memdesc:a058d8c5c5b709e7c1ab87818dc4d036e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true once the filter is initialised from and IMU velocity. <br /></td></tr>
<tr class="separator:a058d8c5c5b709e7c1ab87818dc4d036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523e1fe804a5b79cd3c2a0fb569a2ce5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVisionMeasurement.html">VisionMeasurement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a523e1fe804a5b79cd3c2a0fb569a2ce5">getFeaturePredictions</a> (const GIFT::GICameraPtr &amp;camPtr, const double &amp;stamp=-1)</td></tr>
<tr class="memdesc:a523e1fe804a5b79cd3c2a0fb569a2ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide estimated feature measurements.  <a href="classVIOFilter.html#a523e1fe804a5b79cd3c2a0fb569a2ce5">More...</a><br /></td></tr>
<tr class="separator:a523e1fe804a5b79cd3c2a0fb569a2ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba547fc164d112b72a1941eb17ca91bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVIOState.html">VIOState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#aba547fc164d112b72a1941eb17ca91bb">stateEstimate</a> () const</td></tr>
<tr class="memdesc:aba547fc164d112b72a1941eb17ca91bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide the current system state estimate.  <a href="classVIOFilter.html#aba547fc164d112b72a1941eb17ca91bb">More...</a><br /></td></tr>
<tr class="separator:aba547fc164d112b72a1941eb17ca91bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aad5e643d245dee8489cbae3dd5f7a2fa"><td class="memItemLeft" align="right" valign="top"><a id="aad5e643d245dee8489cbae3dd5f7a2fa"></a>
std::unique_ptr&lt; <a class="el" href="structVIOFilter_1_1Settings.html">VIOFilter::Settings</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#aad5e643d245dee8489cbae3dd5f7a2fa">settings</a></td></tr>
<tr class="memdesc:aad5e643d245dee8489cbae3dd5f7a2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filter settings, including noise parameters and discretisation settings. <br /></td></tr>
<tr class="separator:aad5e643d245dee8489cbae3dd5f7a2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab5267fbf65a542f18898e369ce22d411"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#ab5267fbf65a542f18898e369ce22d411">integrateUpToTime</a> (const double &amp;newTime, const bool doRiccati=true)</td></tr>
<tr class="memdesc:ab5267fbf65a542f18898e369ce22d411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate the EqF dynamics to the given time without correction terms.  <a href="classVIOFilter.html#ab5267fbf65a542f18898e369ce22d411">More...</a><br /></td></tr>
<tr class="separator:ab5267fbf65a542f18898e369ce22d411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b6ef3b712a0449371d3bae7dfaac3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#ad5b6ef3b712a0449371d3bae7dfaac3d">addNewLandmarks</a> (const <a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> &amp;measurement)</td></tr>
<tr class="memdesc:ad5b6ef3b712a0449371d3bae7dfaac3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new landmarks to the EqF state from the provided features.  <a href="classVIOFilter.html#ad5b6ef3b712a0449371d3bae7dfaac3d">More...</a><br /></td></tr>
<tr class="separator:ad5b6ef3b712a0449371d3bae7dfaac3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4b32bc190efaf0bdccc0b28cf63785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#abb4b32bc190efaf0bdccc0b28cf63785">addNewLandmarks</a> (std::vector&lt; <a class="el" href="structLandmark.html">Landmark</a> &gt; &amp;newLandmarks)</td></tr>
<tr class="memdesc:abb4b32bc190efaf0bdccc0b28cf63785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add new landmarks to the EqF state from the provided features.  <a href="classVIOFilter.html#abb4b32bc190efaf0bdccc0b28cf63785">More...</a><br /></td></tr>
<tr class="separator:abb4b32bc190efaf0bdccc0b28cf63785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1887c641147e5e57cc8c9b4fd350ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#ab1887c641147e5e57cc8c9b4fd350ff4">removeOldLandmarks</a> (const std::vector&lt; int &gt; &amp;measurementIds)</td></tr>
<tr class="memdesc:ab1887c641147e5e57cc8c9b4fd350ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all landmarks with id numbers that do not appear in measurementIds.  <a href="classVIOFilter.html#ab1887c641147e5e57cc8c9b4fd350ff4">More...</a><br /></td></tr>
<tr class="separator:ab1887c641147e5e57cc8c9b4fd350ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91da1d311a309b2660ef3676fd2ebca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a91da1d311a309b2660ef3676fd2ebca4">removeOutliers</a> (<a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> &amp;measurement)</td></tr>
<tr class="memdesc:a91da1d311a309b2660ef3676fd2ebca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify landmarks with outlier measurements and remove them from the EqF states and the measurement, respectively.  <a href="classVIOFilter.html#a91da1d311a309b2660ef3676fd2ebca4">More...</a><br /></td></tr>
<tr class="separator:a91da1d311a309b2660ef3676fd2ebca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699db7d54a02a09e57b7c7660380a257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a699db7d54a02a09e57b7c7660380a257">removeLandmarkByIndex</a> (const int &amp;idx)</td></tr>
<tr class="memdesc:a699db7d54a02a09e57b7c7660380a257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a landmark from the EqF states based on its index in the EqF state vector.  <a href="classVIOFilter.html#a699db7d54a02a09e57b7c7660380a257">More...</a><br /></td></tr>
<tr class="separator:a699db7d54a02a09e57b7c7660380a257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70b81ebf20378abb224180f8f2e2eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#af70b81ebf20378abb224180f8f2e2eb9">removeLandmarkById</a> (const int &amp;id)</td></tr>
<tr class="memdesc:af70b81ebf20378abb224180f8f2e2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a landmark from the EqF states based on its id number.  <a href="classVIOFilter.html#af70b81ebf20378abb224180f8f2e2eb9">More...</a><br /></td></tr>
<tr class="separator:af70b81ebf20378abb224180f8f2e2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d016a6e20779131c09edf3022bc169"><td class="memItemLeft" align="right" valign="top"><a id="a94d016a6e20779131c09edf3022bc169"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a94d016a6e20779131c09edf3022bc169">removeInvalidLandmarks</a> ()</td></tr>
<tr class="memdesc:a94d016a6e20779131c09edf3022bc169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all landmarks with depth values that are too small or too large. <br /></td></tr>
<tr class="separator:a94d016a6e20779131c09edf3022bc169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8b00174627c85f619004143ca55b9"><td class="memItemLeft" align="right" valign="top"><a id="a4cc8b00174627c85f619004143ca55b9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a4cc8b00174627c85f619004143ca55b9">getMedianSceneDepth</a> () const</td></tr>
<tr class="memdesc:a4cc8b00174627c85f619004143ca55b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of the depth values of all the landmarks. <br /></td></tr>
<tr class="separator:a4cc8b00174627c85f619004143ca55b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c108ee337f3a366171bfefbe366c9"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#ad11c108ee337f3a366171bfefbe366c9">getLandmarkCovById</a> (const int &amp;id) const</td></tr>
<tr class="memdesc:ad11c108ee337f3a366171bfefbe366c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the marginalised covariance associated with a landmark by its id number.  <a href="classVIOFilter.html#ad11c108ee337f3a366171bfefbe366c9">More...</a><br /></td></tr>
<tr class="separator:ad11c108ee337f3a366171bfefbe366c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8d0fb170bf4ecd2e4e0e4611eddc84"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a9a8d0fb170bf4ecd2e4e0e4611eddc84">getOutputCovById</a> (const int &amp;id, const Eigen::Vector2d &amp;y, const GIFT::GICameraPtr &amp;camPtr) const</td></tr>
<tr class="memdesc:a9a8d0fb170bf4ecd2e4e0e4611eddc84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the covariance associated with the measurement of a particular value.  <a href="classVIOFilter.html#a9a8d0fb170bf4ecd2e4e0e4611eddc84">More...</a><br /></td></tr>
<tr class="separator:a9a8d0fb170bf4ecd2e4e0e4611eddc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a02dc49198899d905ca12866c1a87ba61"><td class="memItemLeft" align="right" valign="top"><a id="a02dc49198899d905ca12866c1a87ba61"></a>
<a class="el" href="structEqFCoordinateSuite.html">EqFCoordinateSuite</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a02dc49198899d905ca12866c1a87ba61">coordinateSuite</a> = &amp;<a class="el" href="EqFMatrices_8h.html#a6e9c7da2628968456f60b3a4730a7038">EqFCoordinateSuite_euclid</a></td></tr>
<tr class="memdesc:a02dc49198899d905ca12866c1a87ba61"><td class="mdescLeft">&#160;</td><td class="mdescRight">The suite of EqF matrix functions. <br /></td></tr>
<tr class="separator:a02dc49198899d905ca12866c1a87ba61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880b74d04b065f33a42e11291ace26f2"><td class="memItemLeft" align="right" valign="top"><a id="a880b74d04b065f33a42e11291ace26f2"></a>
<a class="el" href="structVIOState.html">VIOState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a880b74d04b065f33a42e11291ace26f2">xi0</a></td></tr>
<tr class="memdesc:a880b74d04b065f33a42e11291ace26f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fixed origin configuration. <br /></td></tr>
<tr class="separator:a880b74d04b065f33a42e11291ace26f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d466f01db88175d31aa819c44da2fb3"><td class="memItemLeft" align="right" valign="top"><a id="a1d466f01db88175d31aa819c44da2fb3"></a>
<a class="el" href="structVIOGroup.html">VIOGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a1d466f01db88175d31aa819c44da2fb3">X</a> = <a class="el" href="structVIOGroup.html#aafebae3c42dd977212e62162729a7b28">VIOGroup::Identity</a>()</td></tr>
<tr class="memdesc:a1d466f01db88175d31aa819c44da2fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EqF's observer state. <br /></td></tr>
<tr class="separator:a1d466f01db88175d31aa819c44da2fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1648b12d1d904531fa98dbea53b4fa"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#aba1648b12d1d904531fa98dbea53b4fa">Sigma</a></td></tr>
<tr class="memdesc:aba1648b12d1d904531fa98dbea53b4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The EqF's Riccati matrix.  <a href="classVIOFilter.html#aba1648b12d1d904531fa98dbea53b4fa">More...</a><br /></td></tr>
<tr class="separator:aba1648b12d1d904531fa98dbea53b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaa8756b5ee9c0a531b8ff351bd3cc8"><td class="memItemLeft" align="right" valign="top"><a id="adcaa8756b5ee9c0a531b8ff351bd3cc8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#adcaa8756b5ee9c0a531b8ff351bd3cc8">initialisedFlag</a> = false</td></tr>
<tr class="memdesc:adcaa8756b5ee9c0a531b8ff351bd3cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">True once the EqF has been initialised from an IMU velocity measurement. <br /></td></tr>
<tr class="separator:adcaa8756b5ee9c0a531b8ff351bd3cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57ce0b5e3712eda09016da4801dd82e"><td class="memItemLeft" align="right" valign="top"><a id="ae57ce0b5e3712eda09016da4801dd82e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#ae57ce0b5e3712eda09016da4801dd82e">currentTime</a> = -1</td></tr>
<tr class="memdesc:ae57ce0b5e3712eda09016da4801dd82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time of the last measurement processed. <br /></td></tr>
<tr class="separator:ae57ce0b5e3712eda09016da4801dd82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b579aa1919ed93cce8577eb781fe4c"><td class="memItemLeft" align="right" valign="top"><a id="a69b579aa1919ed93cce8577eb781fe4c"></a>
<a class="el" href="structIMUVelocity.html">IMUVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a69b579aa1919ed93cce8577eb781fe4c">currentVelocity</a> = <a class="el" href="structIMUVelocity.html#a25ceed4227a21bbdeacf1cf2b3d6a581">IMUVelocity::Zero</a>()</td></tr>
<tr class="memdesc:a69b579aa1919ed93cce8577eb781fe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The latest IMU velocity measurement. <br /></td></tr>
<tr class="separator:a69b579aa1919ed93cce8577eb781fe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0409eb4257dd0a0dc3d6aaae45406aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structIMUVelocity.html">IMUVelocity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#aa0409eb4257dd0a0dc3d6aaae45406aa">accumulatedVelocity</a></td></tr>
<tr class="memdesc:aa0409eb4257dd0a0dc3d6aaae45406aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of all IMU velocities since the last image measurement.  <a href="classVIOFilter.html#aa0409eb4257dd0a0dc3d6aaae45406aa">More...</a><br /></td></tr>
<tr class="separator:aa0409eb4257dd0a0dc3d6aaae45406aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b7c995868e4b9aa2f97337d8acb3f5"><td class="memItemLeft" align="right" valign="top"><a id="a20b7c995868e4b9aa2f97337d8acb3f5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a20b7c995868e4b9aa2f97337d8acb3f5">accumulatedTime</a> = 0.0</td></tr>
<tr class="memdesc:a20b7c995868e4b9aa2f97337d8acb3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The time since the last image measurement. <br /></td></tr>
<tr class="separator:a20b7c995868e4b9aa2f97337d8acb3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2957bf22d78c274275893bb6b8c38b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCSVLine.html">CSVLine</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVIOFilter.html#a2957bf22d78c274275893bb6b8c38b30">operator&lt;&lt;</a> (<a class="el" href="classCSVLine.html">CSVLine</a> &amp;line, const <a class="el" href="classVIOFilter.html">VIOFilter</a> &amp;filter)</td></tr>
<tr class="memdesc:a2957bf22d78c274275893bb6b8c38b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an the filter states to a file.  <a href="classVIOFilter.html#a2957bf22d78c274275893bb6b8c38b30">More...</a><br /></td></tr>
<tr class="separator:a2957bf22d78c274275893bb6b8c38b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The implementation of the EqF for VIO. </p>
<p>This class implements the equivariant filter for visual inertial odometry. Aside from the basic EqF dynamics, this implementation also features methods for outlier rejection, state augmentation, and buffering IMU measurements. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a666a3413e027f049fe82065a0a4cd0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666a3413e027f049fe82065a0a4cd0b3">&#9670;&nbsp;</a></span>VIOFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VIOFilter::VIOFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVIOFilter_1_1Settings.html">VIOFilter::Settings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the EqF using the given settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>The initial settings to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad5b6ef3b712a0449371d3bae7dfaac3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b6ef3b712a0449371d3bae7dfaac3d">&#9670;&nbsp;</a></span>addNewLandmarks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::addNewLandmarks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> &amp;&#160;</td>
          <td class="paramname"><em>measurement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new landmarks to the EqF state from the provided features. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurement</td><td>The features to use when adding new landmarks.</td></tr>
  </table>
  </dd>
</dl>
<p>If there are any features with id numbers that are not already part of the state, then new landmark states are added to the state from those features. Depending on the chosen settings, these landmarks are initialised with either the median scene depth or a fixed depth value. </p>

</div>
</div>
<a id="abb4b32bc190efaf0bdccc0b28cf63785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4b32bc190efaf0bdccc0b28cf63785">&#9670;&nbsp;</a></span>addNewLandmarks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::addNewLandmarks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structLandmark.html">Landmark</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newLandmarks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add new landmarks to the EqF state from the provided features. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newLandmarks</td><td>The landmarks to be added to the state.</td></tr>
  </table>
  </dd>
</dl>
<p>This method adds new landmarks to the state exactly as they are provided, and augments the Riccati matrix as appropriate. </p>

</div>
</div>
<a id="a523e1fe804a5b79cd3c2a0fb569a2ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523e1fe804a5b79cd3c2a0fb569a2ce5">&#9670;&nbsp;</a></span>getFeaturePredictions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> VIOFilter::getFeaturePredictions </td>
          <td>(</td>
          <td class="paramtype">const GIFT::GICameraPtr &amp;&#160;</td>
          <td class="paramname"><em>camPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>stamp</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide estimated feature measurements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camPtr</td><td>The camera model used to compute the predictions </td></tr>
    <tr><td class="paramname">stamp</td><td>The requested time stamp of the predictions. Defaults to the current filter time.</td></tr>
  </table>
  </dd>
</dl>
<p>Compute the predicted feature measurements based on the provided camera model. If a time stamp is provided, then the filter is first integrated up to this time. This method can be helpful in aiding feature tracking under rapid motions. </p>

</div>
</div>
<a id="ad11c108ee337f3a366171bfefbe366c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11c108ee337f3a366171bfefbe366c9">&#9670;&nbsp;</a></span>getLandmarkCovById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix3d VIOFilter::getLandmarkCovById </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the marginalised covariance associated with a landmark by its id number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id number of the landmark with the desired covariance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8d0fb170bf4ecd2e4e0e4611eddc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8d0fb170bf4ecd2e4e0e4611eddc84">&#9670;&nbsp;</a></span>getOutputCovById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix2d VIOFilter::getOutputCovById </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GIFT::GICameraPtr &amp;&#160;</td>
          <td class="paramname"><em>camPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the covariance associated with the measurement of a particular value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id number to which the measurement covariance is associated. </td></tr>
    <tr><td class="paramname">y</td><td>The real measurement of pixel coordinates associated with this id number. </td></tr>
    <tr><td class="paramname">camPtr</td><td>The camera model for the camera used to make the measurement y.</td></tr>
  </table>
  </dd>
</dl>
<p>The availability of the true measurement y allows us to use an equivariant output approximation here. </p>

</div>
</div>
<a id="a26fd317292c498fbf744556e479d9820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fd317292c498fbf744556e479d9820">&#9670;&nbsp;</a></span>initialiseFromIMUData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::initialiseFromIMUData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIMUVelocity.html">IMUVelocity</a> &amp;&#160;</td>
          <td class="paramname"><em>imuVelocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the EqF states using an IMU velocity measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imuVelocity</td><td>The IMU velocity to use in initialisation.</td></tr>
  </table>
  </dd>
</dl>
<p>It is assumed that the IMU acceleration is almost entirely due to gravity, allowing us to determine the pitch and roll components of the robot's orientation. It is important to do this at the start. </p>

</div>
</div>
<a id="ab5267fbf65a542f18898e369ce22d411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5267fbf65a542f18898e369ce22d411">&#9670;&nbsp;</a></span>integrateUpToTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool VIOFilter::integrateUpToTime </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>newTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>doRiccati</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate the EqF dynamics to the given time without correction terms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTime</td><td>The time to which the EqF states should be integrated. </td></tr>
    <tr><td class="paramname">doRiccati</td><td>Propagate the Riccati matrix iff this is true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff the integration could be performed.</dd></dl>
<p>If doRiccati is set to true, then the Riccati matrix is propagated without the correction terms. This is an expensive operation, however, so it is generally better just to propagate the Riccati upon receiving a new image measurement by using the average IMU velocity. If newTime is less than the current filter time or the filter is not yet initialised, then the integration cannot go ahead and this method returns false. </p>

</div>
</div>
<a id="a787faa9c8ad05a0eeeaa88076ac381bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787faa9c8ad05a0eeeaa88076ac381bd">&#9670;&nbsp;</a></span>processIMUData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::processIMUData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structIMUVelocity.html">IMUVelocity</a> &amp;&#160;</td>
          <td class="paramname"><em>imuVelocity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process an IMU velocity measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imuVelocity</td><td>The IMU velocity to process.</td></tr>
  </table>
  </dd>
</dl>
<p>The EqF is integrated using the given IMU velocity measurement. Depending on the settings, the Riccati matrix may or may not be propagated at this time. The given IMU velocity is recorded as the current velocity. </p>

</div>
</div>
<a id="a2c10aed6c58f2b292be63523a57b8b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c10aed6c58f2b292be63523a57b8b2e">&#9670;&nbsp;</a></span>processVisionData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::processVisionData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> &amp;&#160;</td>
          <td class="paramname"><em>measurement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process a vision measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurement</td><td>The measurement of feature points obtained from the front-end.</td></tr>
  </table>
  </dd>
</dl>
<p>A number of steps are undertaken when processing vision data. First, the EqF is integrated using the latest velocity, and the Riccati matrix is propagated to the current time. Second, any landmarks that were not tracked successfully, or those that are associated with outlier measurements, are removed from the EqF state. Third and final, the EqF correction terms are computed and applied. </p>

</div>
</div>
<a id="af70b81ebf20378abb224180f8f2e2eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70b81ebf20378abb224180f8f2e2eb9">&#9670;&nbsp;</a></span>removeLandmarkById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::removeLandmarkById </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a landmark from the EqF states based on its id number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id number of the landmark to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a699db7d54a02a09e57b7c7660380a257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699db7d54a02a09e57b7c7660380a257">&#9670;&nbsp;</a></span>removeLandmarkByIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::removeLandmarkByIndex </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a landmark from the EqF states based on its index in the EqF state vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the landmark to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1887c641147e5e57cc8c9b4fd350ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1887c641147e5e57cc8c9b4fd350ff4">&#9670;&nbsp;</a></span>removeOldLandmarks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::removeOldLandmarks </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurementIds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all landmarks with id numbers that do not appear in measurementIds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurementIds</td><td>The ids of landmarks that will be kept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91da1d311a309b2660ef3676fd2ebca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91da1d311a309b2660ef3676fd2ebca4">&#9670;&nbsp;</a></span>removeOutliers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::removeOutliers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVisionMeasurement.html">VisionMeasurement</a> &amp;&#160;</td>
          <td class="paramname"><em>measurement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify landmarks with outlier measurements and remove them from the EqF states and the measurement, respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurement</td><td>The current measurement.</td></tr>
  </table>
  </dd>
</dl>
<p>This method uses both an absolute check and a covariance-based check. If a measurement differs from the expected measurement by more than a set value, then it is considered an outlier. If weighted measurement distance is larger than a set value, it is also considered an outlier. </p>

</div>
</div>
<a id="a05118d5a1b771aed7b384e84bb341108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05118d5a1b771aed7b384e84bb341108">&#9670;&nbsp;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VIOFilter::setState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVIOState.html">VIOState</a> &amp;&#160;</td>
          <td class="paramname"><em>xi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the EqF using the given state xi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xi</td><td>The state to which the EqF should be set.</td></tr>
  </table>
  </dd>
</dl>
<p>Given a state xi, the origin xi0 is set to xi, the state X is set to identity, and the Riccati matrix Sigma is set to its default values. </p>

</div>
</div>
<a id="aba547fc164d112b72a1941eb17ca91bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba547fc164d112b72a1941eb17ca91bb">&#9670;&nbsp;</a></span>stateEstimate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVIOState.html">VIOState</a> VIOFilter::stateEstimate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide the current system state estimate. </p>
<p>This is computed by applying the group action with the observer state X to the fixed origin configuration xi0. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2957bf22d78c274275893bb6b8c38b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2957bf22d78c274275893bb6b8c38b30">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCSVLine.html">CSVLine</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCSVLine.html">CSVLine</a> &amp;&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVIOFilter.html">VIOFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write an the filter states to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>A reference to the CSV line where the data should be written. </td></tr>
    <tr><td class="paramname">filter</td><td>The filter states to write to the CSV line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the CSV line with the data written.</dd></dl>
<p>The data is formatted in the CSV line as [xi0, X, Sigma] </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa0409eb4257dd0a0dc3d6aaae45406aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0409eb4257dd0a0dc3d6aaae45406aa">&#9670;&nbsp;</a></span>accumulatedVelocity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structIMUVelocity.html">IMUVelocity</a> VIOFilter::accumulatedVelocity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        <a class="code" href="structIMUVelocity.html#a25ceed4227a21bbdeacf1cf2b3d6a581">IMUVelocity::Zero</a>()</div>
</div><!-- fragment -->
<p>The sum of all IMU velocities since the last image measurement. </p>

</div>
</div>
<a id="aba1648b12d1d904531fa98dbea53b4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1648b12d1d904531fa98dbea53b4fa">&#9670;&nbsp;</a></span>Sigma</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd VIOFilter::Sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        Eigen::MatrixXd::Identity(<a class="code" href="structVIOSensorState.html#a233cae54fe0d151114a44312d66b9f90">VIOSensorState::CompDim</a>, <a class="code" href="structVIOSensorState.html#a233cae54fe0d151114a44312d66b9f90">VIOSensorState::CompDim</a>)</div>
</div><!-- fragment -->
<p>The EqF's Riccati matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/eqvio/<a class="el" href="VIOFilter_8h_source.html">VIOFilter.h</a></li>
<li>src/VIOFilter.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructVIOSensorState_html_a233cae54fe0d151114a44312d66b9f90"><div class="ttname"><a href="structVIOSensorState.html#a233cae54fe0d151114a44312d66b9f90">VIOSensorState::CompDim</a></div><div class="ttdeci">constexpr static int CompDim</div><div class="ttdoc">The dimesion of the space of sensor states.</div><div class="ttdef"><b>Definition:</b> VIOState.h:63</div></div>
<div class="ttc" id="astructIMUVelocity_html_a25ceed4227a21bbdeacf1cf2b3d6a581"><div class="ttname"><a href="structIMUVelocity.html#a25ceed4227a21bbdeacf1cf2b3d6a581">IMUVelocity::Zero</a></div><div class="ttdeci">static IMUVelocity Zero()</div><div class="ttdoc">An IMUVelocity with zero acc and gyr.</div><div class="ttdef"><b>Definition:</b> IMUVelocity.cpp:20</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
